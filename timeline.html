<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Serie temporal laboral — interactiva</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#f4f7fb; --card:#ffffff; --muted:#64748b; --accent: linear-gradient(90deg,#2575fc,#6a11cb);
  }
  *{box-sizing:border-box}
  body{font-family:Inter,system-ui,Arial;margin:0;background:var(--bg);color:#0f172a}
  .container{max-width:1200px;margin:28px auto;padding:16px}

  /* Top control panel */
  .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between}
  .left-controls{display:flex;gap:12px;align-items:center}
  .filters{display:flex;gap:8px;align-items:center}
  .filter-btn{display:flex;align-items:center;gap:8px;padding:8px 10px;background:var(--card);border-radius:10px;box-shadow:0 4px 12px rgba(2,6,23,0.08);cursor:pointer}
  .filter-color{width:12px;height:12px;border-radius:3px}
  .zoom-group{display:flex;gap:6px}
  .btn{padding:8px 12px;border-radius:8px;background:#0f172a;color:#fff;border:none;cursor:pointer}

  /* Timeline area */
  .panel{margin-top:16px;background:var(--card);border-radius:14px;padding:18px;box-shadow:0 6px 20px rgba(2,6,23,0.06)}
  .timeline-area{position:relative;height:420px;width:100%;overflow:hidden;border-radius:10px}
  .timeline-canvas{position:absolute;inset:0}

  /* Points and tooltip */
  .point{position:absolute;width:18px;height:18px;border-radius:50%;transform:translate(-50%,-50%);box-shadow:0 6px 16px rgba(2,6,23,0.12);cursor:pointer}
  .pulse{animation:pulse 2000ms infinite}
  @keyframes pulse{0%{transform:translate(-50%,-50%) scale(1);}50%{transform:translate(-50%,-50%) scale(1.4);}100%{transform:translate(-50%,-50%) scale(1);}}
  .tooltip{position:absolute;background:var(--card);padding:12px;border-radius:10px;box-shadow:0 8px 24px rgba(2,6,23,0.12);max-width:280px;pointer-events:none;border-left:4px solid transparent}
  .tooltip h4{margin:0 0 6px;font-size:14px}
  .tooltip p{margin:0;color:var(--muted);font-size:13px;line-height:1.2}

  /* Legend */
  .legend{display:flex;gap:14px;flex-wrap:wrap;margin-top:12px}
  .legend-item{display:flex;gap:8px;align-items:center;background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent);padding:6px 10px;border-radius:8px}
  .legend-key{width:14px;height:14px;border-radius:3px}

  /* Bottom charts */
  .charts{display:flex;gap:16px;margin-top:16px;flex-wrap:wrap}
  .chart-card{flex:1;min-width:280px;background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.06)}

  /* Responsive tweaks */
  @media (max-width:760px){
    .timeline-area{height:360px}
    .controls{flex-direction:column;align-items:flex-start}
    .charts{flex-direction:column}
  }
</style>
</head>
<body>
<div class="container">
  <div class="controls">
    <div class="left-controls">
      <div style="font-weight:700">Serie temporal laboral</div>
      <div class="filters" id="filters"></div>
    </div>
    <div class="zoom-group">
      <button class="btn" id="fitBtn" title="Ajustar vista">Ajustar</button>
      <button class="btn" id="resetBtn" title="Resetear zoom">Reset</button>
    </div>
  </div>

  <div class="panel">
    <div class="timeline-area" id="timelineArea">
      <canvas id="timelineCanvas" class="timeline-canvas"></canvas>
      <!-- tooltip -->
      <div id="tooltip" class="tooltip" style="display:none; border-left-color:#2575fc"></div>
    </div>

    <div class="legend" id="legend"></div>

    <div class="charts">
      <div class="chart-card">
        <canvas id="sectorChart" height="140"></canvas>
      </div>
      <div class="chart-card">
        <canvas id="trendChart" height="140"></canvas>
      </div>
    </div>
  </div>
</div>

<!-- Libraries (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
/* --- Data: keep date strings and categories --- */
const rawEvents = [
  {start:'1995-09-01',end:'1995-10-31',label:'Mozo de almacén',category:'otros'},
  {start:'2000-02-01',end:'2000-03-31',label:'Promotor',category:'otros'},
  {start:'2000-06-01',end:'2000-07-31',label:'Grabador de datos (Sevilla 99)',category:'admin'},
  {start:'2000-12-01',end:'2001-03-31',label:'Dependiente tienda',category:'otros'},
  {start:'2001-07-01',end:'2002-12-31',label:'Técnico equipo informático',category:'it'},
  {start:'2003-01-01',end:'2003-09-30',label:'Responsable montaje equipos',category:'it'},
  {start:'2004-07-01',end:'2004-08-31',label:'Auxiliar cafetería',category:'hostel'},
  {start:'2005-06-01',end:'2005-09-30',label:'Encargado de barra',category:'hostel'},
  {start:'2006-02-01',end:'2006-04-30',label:'Instalador ONO',category:'it'},
  {start:'2006-08-01',end:'2006-09-30',label:'Camarero',category:'hostel'},
  {start:'2006-10-01',end:'2007-03-31',label:'Dependiente tienda foto',category:'design'},
  {start:'2007-05-01',end:'2007-11-30',label:'Encargado de bar',category:'hostel'},
  {start:'2008-05-01',end:'2010-09-30',label:'Gestor telefónico (SITEL)',category:'it'},
  {start:'2015-07-01',end:'2018-08-31',label:'Técnico laboratorio y administrativo I+D',category:'it'},
  {start:'2021-12-01',end:'2021-12-31',label:'Auxiliar administrativo contable',category:'admin'},
  {start:'2023-06-01',end:'2023-07-31',label:'Desarrollo web (LAYBET)',category:'it'},
  {start:'2024-06-01',end:'2024-08-31',label:'Diseñador gráfico preprensa (LUMAPRINT)',category:'design'}
];

/* Category styling */
const categories = {
  it:   {name:'IT & Tecnología', color:['#6fb1ff','#2575fc']},
  design:{name:'Diseño & Multimedia', color:['#c295ff','#6a11cb']},
  admin:{name:'Administración', color:['#9ff6e0','#15d1c2']},
  hostel:{name:'Hostelería', color:['#ffd9b3','#ff9f43']},
  otros:{name:'Otros', color:['#ffc7c7','#ff4757']}
};

/* Utilities */
function toTime(d){return (new Date(d)).getTime()}
const allTimes = rawEvents.flatMap(e=>[toTime(e.start), toTime(e.end)]);
const minT = Math.min(...allTimes), maxT = Math.max(...allTimes);

/* Canvas & responsiveness */
const area = document.getElementById('timelineArea');
const canvas = document.getElementById('timelineCanvas');
const ctx = canvas.getContext('2d');
let width, height, dpr = window.devicePixelRatio || 1;
function resize(){width=area.clientWidth;height=area.clientHeight;canvas.width=width*dpr;canvas.height=height*dpr;canvas.style.width=width+'px';canvas.style.height=height+'px';ctx.setTransform(dpr,0,0,dpr,0,0);draw();}
window.addEventListener('resize',resize);

/* Zoom & pan state */
let view = {scale:1,offsetX:0};
let isPanning=false,startPanX=0,startOffsetX=0;
canvas.addEventListener('wheel',e=>{e.preventDefault();const delta = -e.deltaY/500;const old = view.scale;view.scale = Math.min(3,Math.max(0.6, view.scale*(1+delta)));draw();});
canvas.addEventListener('mousedown',e=>{isPanning=true;startPanX=e.clientX;startOffsetX=view.offsetX;canvas.style.cursor='grabbing'});
window.addEventListener('mouseup',()=>{isPanning=false;canvas.style.cursor='default'});
window.addEventListener('mousemove',e=>{if(isPanning){const dx = (e.clientX-startPanX);view.offsetX = startOffsetX + dx;draw();} else handleHover(e);});

/* Fit & reset */
document.getElementById('fitBtn').addEventListener('click',()=>{view.scale=1;view.offsetX=0;draw();});
document.getElementById('resetBtn').addEventListener('click',()=>{view.scale=1;view.offsetX=0;draw();});

/* Compute X position normalized by time */
function timeToX(t){const norm = (t-minT)/(maxT-minT); return 60 + norm*(width-120); }

/* Generate Y positions with deterministic pseudo-random to avoid overlap */
function seeded(val){let x = Math.sin(val)*10000; return x - Math.floor(x);} 
function computePoints(filtered){return filtered.map(e=>{
  const mid = (toTime(e.start)+toTime(e.end))/2;
  const x = timeToX(mid)*view.scale + view.offsetX;
  // jitter up/down
  const jitter = (seeded(mid)*0.6-0.3)*(height*0.35);
  const y = height/2 + jitter;
  return {...e,x,y,mid};
});}

/* Draw timeline baseline and points */
function draw(){ctx.clearRect(0,0,width,height);
  // baseline gradient
  const g = ctx.createLinearGradient(0,0,width,0);
  g.addColorStop(0,categories.design.color[0]);g.addColorStop(0.5,categories.it.color[1]);g.addColorStop(1,categories.admin.color[1]);
  ctx.fillStyle=g; ctx.fillRect(40,height/2-4,width-80,8);

  // draw points
  const visible = rawEvents.filter(e=>visibleCats.has(e.category));
  const pts = computePoints(visible);

  // regression — compute using mid timestamps for visible points
  const xs = pts.map(p=>p.mid);
  const ys = pts.map(p=>p.y);
  if(xs.length>1){ const reg = linearRegression(xs,ys); drawRegression(reg); }

  pts.forEach(p=>{
    // circle with stroke gradient
    const cat = categories[p.category];
    const grad = ctx.createLinearGradient(p.x-10,p.y-10,p.x+10,p.y+10);
    grad.addColorStop(0,cat.color[0]); grad.addColorStop(1,cat.color[1]);
    ctx.beginPath(); ctx.fillStyle=grad; ctx.arc(p.x,p.y,9,0,Math.PI*2); ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.stroke();
  });
}

/* Regression drawing */
function linearRegression(xs,ys){ const n=xs.length; const sx=xs.reduce((a,b)=>a+b,0); const sy=ys.reduce((a,b)=>a+b,0); const sxx=xs.reduce((a,b)=>a+b*b,0); const sxy=xs.reduce((a,i,idx)=>a+ i*ys[idx],0); const m=(n*sxy - sx*sy)/(n*sxx - sx*sx); const b=(sy - m*sx)/n; return {m,b}; }
function drawRegression(reg){ // draw line across time range
  const x1 = timeToX(minT)*view.scale + view.offsetX; const x2 = timeToX(maxT)*view.scale + view.offsetX;
  // convert x back to time for y = m*t + b, need to map x->t: reverse of timeToX
  const tForX = x=> { const norm = (x - 60 - view.offsetX)/(width-120)/view.scale; return minT + norm*(maxT-minT); }
  ctx.beginPath(); ctx.lineWidth=3; ctx.setLineDash([8,6]);
  // gradient for regression
  const g = ctx.createLinearGradient(x1,0,x2,0); g.addColorStop(0,'#2575fc'); g.addColorStop(1,'#15d1c2'); ctx.strokeStyle=g;
  const tA = tForX(60); const tB = tForX(width-60);
  const yA = reg.m * tA + reg.b; const yB = reg.m * tB + reg.b;
  ctx.moveTo(x1,yA); ctx.lineTo(x2,yB); ctx.stroke(); ctx.setLineDash([]);
}

/* Hover handling: show tooltip when near a point */
const tooltip = document.getElementById('tooltip');
let visibleCats = new Set(Object.keys(categories));
function handleHover(e){const rect = canvas.getBoundingClientRect(); const mx = (e.clientX - rect.left); const my = (e.clientY - rect.top);
  const visible = rawEvents.filter(ev=>visibleCats.has(ev.category)); const pts = computePoints(visible);
  const found = pts.find(p=>Math.hypot(p.x-mx,p.y-my) < 12);
  if(found){ tooltip.style.display='block'; tooltip.style.left = Math.min(width-300,found.x+12)+'px'; tooltip.style.top = Math.max(8,found.y-60)+'px'; tooltip.innerHTML = `<h4>${found.label}</h4><p>${formatDate(found.start)} → ${formatDate(found.end)}<br><strong>${categories[found.category].name}</strong></p>`; tooltip.style.borderLeftColor = categories[found.category].color[1]; } else tooltip.style.display='none'; }
function formatDate(d){ const dt=new Date(d); return dt.toLocaleDateString(); }

/* Legend & filters */
const legendEl = document.getElementById('legend'); const filtersEl = document.getElementById('filters');
Object.keys(categories).forEach(key=>{
  const c = categories[key];
  const item = document.createElement('div'); item.className='legend-item'; item.innerHTML = `<div style='width:12px;height:12px;border-radius:3px;background:linear-gradient(180deg,${c.color[0]},${c.color[1]})'></div><div style='font-size:13px'>${c.name}</div>`; legendEl.appendChild(item);
  // filter button
  const btn = document.createElement('button'); btn.className='filter-btn'; btn.innerHTML = `<div class='filter-color' style='background:${c.color[1]}'></div><div style='font-size:13px'>${c.name}</div>`;
  btn.onclick = ()=>{ if(visibleCats.has(key)){ visibleCats.delete(key); btn.style.opacity=0.5;} else { visibleCats.add(key); btn.style.opacity=1;} updateCharts(); draw(); };
  filtersEl.appendChild(btn);
});

/* Secondary charts using Chart.js */
let sectorChart, trendChart;
function updateCharts(){ const counts = {}; Object.keys(categories).forEach(k=>counts[k]=0);
  rawEvents.forEach(ev=>{ if(visibleCats.has(ev.category)) counts[ev.category]+= (toTime(ev.end)-toTime(ev.start)); });
  const total = Object.values(counts).reduce((a,b)=>a+b,0)||1;
  const percents = Object.keys(counts).map(k=>Math.round(counts[k]/total*100));
  const labels = Object.keys(categories).map(k=>categories[k].name);
  if(!sectorChart){ sectorChart = new Chart(document.getElementById('sectorChart'),{type:'doughnut',data:{labels, datasets:[{data:percents, backgroundColor: Object.keys(categories).map(k=>categories[k].color[1])}]}, options:{responsive:true,plugins:{legend:{display:false}}}});
  } else { sectorChart.data.datasets[0].data = percents; sectorChart.update(); }

  // Trend chart: number of IT points over time (simplified)
  const years = []; for(let y=new Date(minT).getFullYear(); y<=new Date(maxT).getFullYear(); y++) years.push(y);
  const countsByYear = years.map(y=> rawEvents.filter(ev=> visibleCats.has(ev.category) && new Date(ev.start).getFullYear()<=y && new Date(ev.end).getFullYear()>=y).length);
  if(!trendChart){ trendChart = new Chart(document.getElementById('trendChart'),{type:'line',data:{labels:years, datasets:[{label:'Ocurrencias (por año)', data:countsByYear, fill:true, tension:0.35, backgroundColor:'rgba(37,117,252,0.12)', borderColor:'#2575fc'}]}, options:{responsive:true, plugins:{legend:{display:false}}}});
  } else { trendChart.data.datasets[0].data = countsByYear; trendChart.update(); }
}

/* Init */
resize(); updateCharts(); draw();

</script>
</body>
</html>
